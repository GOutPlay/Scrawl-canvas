<!DOCTYPE html>

<html>
<head>
  <title>Filter factory</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="../../docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">
              
                
                <a class="source" href="../core/animationloop.html">
                  ./source/core/animationloop.js
                </a>
              
                
                <a class="source" href="../core/component.html">
                  ./source/core/component.js
                </a>
              
                
                <a class="source" href="../core/document.html">
                  ./source/core/document.js
                </a>
              
                
                <a class="source" href="../core/init.html">
                  ./source/core/init.js
                </a>
              
                
                <a class="source" href="../core/library.html">
                  ./source/core/library.js
                </a>
              
                
                <a class="source" href="../core/userInteraction.html">
                  ./source/core/userInteraction.js
                </a>
              
                
                <a class="source" href="../core/utilities.html">
                  ./source/core/utilities.js
                </a>
              
                
                <a class="source" href="action.html">
                  ./source/factory/action.js
                </a>
              
                
                <a class="source" href="anchor.html">
                  ./source/factory/anchor.js
                </a>
              
                
                <a class="source" href="animation.html">
                  ./source/factory/animation.js
                </a>
              
                
                <a class="source" href="block.html">
                  ./source/factory/block.js
                </a>
              
                
                <a class="source" href="canvas.html">
                  ./source/factory/canvas.js
                </a>
              
                
                <a class="source" href="cell.html">
                  ./source/factory/cell.js
                </a>
              
                
                <a class="source" href="color.html">
                  ./source/factory/color.js
                </a>
              
                
                <a class="source" href="coordinate.html">
                  ./source/factory/coordinate.js
                </a>
              
                
                <a class="source" href="element.html">
                  ./source/factory/element.js
                </a>
              
                
                <a class="source" href="filter.html">
                  ./source/factory/filter.js
                </a>
              
                
                <a class="source" href="fontAttributes.html">
                  ./source/factory/fontAttributes.js
                </a>
              
                
                <a class="source" href="gradient.html">
                  ./source/factory/gradient.js
                </a>
              
                
                <a class="source" href="grid.html">
                  ./source/factory/grid.js
                </a>
              
                
                <a class="source" href="group.html">
                  ./source/factory/group.js
                </a>
              
                
                <a class="source" href="imageAsset.html">
                  ./source/factory/imageAsset.js
                </a>
              
                
                <a class="source" href="loom.html">
                  ./source/factory/loom.js
                </a>
              
                
                <a class="source" href="palette.html">
                  ./source/factory/palette.js
                </a>
              
                
                <a class="source" href="pattern.html">
                  ./source/factory/pattern.js
                </a>
              
                
                <a class="source" href="phrase.html">
                  ./source/factory/phrase.js
                </a>
              
                
                <a class="source" href="picture.html">
                  ./source/factory/picture.js
                </a>
              
                
                <a class="source" href="quaternion.html">
                  ./source/factory/quaternion.js
                </a>
              
                
                <a class="source" href="radialGradient.html">
                  ./source/factory/radialGradient.js
                </a>
              
                
                <a class="source" href="renderAnimation.html">
                  ./source/factory/renderAnimation.js
                </a>
              
                
                <a class="source" href="shape.html">
                  ./source/factory/shape.js
                </a>
              
                
                <a class="source" href="spriteAsset.html">
                  ./source/factory/spriteAsset.js
                </a>
              
                
                <a class="source" href="stack.html">
                  ./source/factory/stack.js
                </a>
              
                
                <a class="source" href="state.html">
                  ./source/factory/state.js
                </a>
              
                
                <a class="source" href="ticker.html">
                  ./source/factory/ticker.js
                </a>
              
                
                <a class="source" href="tween.html">
                  ./source/factory/tween.js
                </a>
              
                
                <a class="source" href="unstackedElement.html">
                  ./source/factory/unstackedElement.js
                </a>
              
                
                <a class="source" href="vector.html">
                  ./source/factory/vector.js
                </a>
              
                
                <a class="source" href="videoAsset.html">
                  ./source/factory/videoAsset.js
                </a>
              
                
                <a class="source" href="wheel.html">
                  ./source/factory/wheel.js
                </a>
              
                
                <a class="source" href="../mixin/anchor.html">
                  ./source/mixin/anchor.js
                </a>
              
                
                <a class="source" href="../mixin/asset.html">
                  ./source/mixin/asset.js
                </a>
              
                
                <a class="source" href="../mixin/assetConsumer.html">
                  ./source/mixin/assetConsumer.js
                </a>
              
                
                <a class="source" href="../mixin/base.html">
                  ./source/mixin/base.js
                </a>
              
                
                <a class="source" href="../mixin/cascade.html">
                  ./source/mixin/cascade.js
                </a>
              
                
                <a class="source" href="../mixin/dom.html">
                  ./source/mixin/dom.js
                </a>
              
                
                <a class="source" href="../mixin/entity.html">
                  ./source/mixin/entity.js
                </a>
              
                
                <a class="source" href="../mixin/filter.html">
                  ./source/mixin/filter.js
                </a>
              
                
                <a class="source" href="../mixin/position.html">
                  ./source/mixin/position.js
                </a>
              
                
                <a class="source" href="../mixin/shapePathCalculation.html">
                  ./source/mixin/shapePathCalculation.js
                </a>
              
                
                <a class="source" href="../mixin/styles.html">
                  ./source/mixin/styles.js
                </a>
              
                
                <a class="source" href="../mixin/tween.html">
                  ./source/mixin/tween.js
                </a>
              
                
                <a class="source" href="../worker/filter.html">
                  ./source/worker/filter.js
                </a>
              
            </div>
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="filter-factory">Filter factory</h1>
<p>Filters take in an image representation of an <a href="../mixin/entity.html">entity</a>, <a href="./group.html">Group</a> of entitys or a <a href="./cell.html">Cell</a> display and, by manipulating the imageâ€™s data, return an updated image which replaces those entitys or cell in the final output display.</p>
<p>Scrawl-canvas defines its filters in <strong>Filter objects</strong>, detailed in this module. The functionality to make use of these objects is coded up in the <a href="../mixin/filter.html">filter mixin</a>, which is used by the Cell, Group and all entity factories.</p>
<p>Scrawl-canvas uses a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API">web worker</a> to generate filter outputs - defined in the <a href="../worker/filter.html">filter web worker</a>. It supports a number of common filter algorithms:</p>
<ul>
<li><code>grayscale</code> - desaturates the image</li>
<li><code>sepia</code> - desaturates the image, then â€˜antiquesâ€™ it by adding back some yellow tone</li>
<li><code>invert</code> - turns white into black, and similar across the spectrum</li>
<li><code>red</code> - suppresses the imageâ€™s green and blue channels</li>
<li><code>green</code> - suppresses the imageâ€™s red and blue channels</li>
<li><code>blue</code> - suppresses the imageâ€™s red and green channels</li>
<li><code>notred</code> - suppresses the imageâ€™s red channel</li>
<li><code>notgreen</code> - suppresses the imageâ€™s green channel</li>
<li><code>notblue</code> - suppresses the imageâ€™s blue channel</li>
<li><code>cyan</code> - averages the imageâ€™s blue and green channels, and suppresses the red channel</li>
<li><code>magenta</code> - averages the imageâ€™s red and blue channels, and suppresses the green channel</li>
<li><code>yellow</code> - averages the imageâ€™s red and green channels, and suppresses the blue channel</li>
<li><code>brightness</code> - multiplies the red, green and blue channel values by a value supplied in the <code>filter.level</code> attribute</li>
<li><code>saturation</code> - multiplies the red, green and blue channel values by a value supplied in the <code>filter.level</code> attribute, then normalizes the result</li>
<li><code>threshold</code> - desaturates each pixel then tests it against <code>filter.level</code> value; those pixels below the level are set to the <code>filter.lowRGB</code> values while the rest are set to the <code>filter.highRGB</code> values</li>
<li><code>channels</code> - multiply each pixelâ€™s channel values by the values set in the <code>filter.RGB</code> attributes</li>
<li><code>channelstep</code> - divide, floor, and then multiply each pixelâ€™s channel values by the values set in the <code>filter.RGB</code> attributes</li>
<li><code>tint</code> - a more fine-grained form of the channels filter</li>
<li><code>chroma</code> - (the green-screen effect) - will evaluate each pixel against a range array; pixels that fall within the range are set to transparent</li>
<li><code>pixelate</code> - create tiles - whose dimensions and positions are determined by values set in the filter <code>tileWidth</code>, <code>tileHeight</code>, <code>offsetX</code> and <code>offsetY</code> attributes - across the image and then average the pixels in each tile to a single color</li>
<li><code>blur</code> - creates a blurred image. Note: can be slow across larger images! The degree of the blur - which does not follow conventional algorithms such as gaussian - is determined by the filter attribute values for <code>radius</code> (number), <code>passes</code> (number) and <code>shrink</code> (boolean)</li>
<li><code>matrix</code> - apply a 3x3 matrix transform to each of the imageâ€™s pixels</li>
<li><code>matrix5</code> - apply a 5x5 matrix transform to each of the imageâ€™s pixels</li>
</ul>
<p>Scrawl-canvas can also use <strong>user-defined filters</strong>.</p>
<p>Filters use the <strong>base</strong> mixin, thus they come equipped with packet functionality, alongside clone and kill functions.</p>
<p>Note that <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/filter">CSS-mediated filters</a> - <code>url()</code>, <code>blur()</code>, <code>brightness()</code>, <code>contrast()</code>, <code>drop-shadow()</code>, <code>grayscale()</code>, <code>hue-rotate()</code>, <code>invert()</code>, <code>opacity()</code>, <code>saturate()</code>, <code>sepia()</code> - can also be applied to DOM elements wrapped into Scrawl-canvas objects (Stack, Element, Canvas) in the normal way. Browsers will apply CSS filters as the final operation in their paint routines.</p>
<p>TODO: weâ€™ve had to include all the code from the <a href="../mixin/filter.html">filter mixin</a> into this file (without comments) because tools like <a href="https://reactjs.org/docs/create-a-new-react-app.html#create-react-app">CreateReactApp</a> - which uses <a href="https://webpack.js.org/">Webpack</a> as its bundler of choice - breaks when we <code>yarn add scrawl-canvas</code> to a project.</p>
<ul>
<li>The root of the issue is that <a href="https://babeljs.io/">Babel</a> currently breaks when it encounters the <code>import.meta</code> attribute.</li>
<li>Babel do supply a plugin which is supposed to address this issue: <a href="https://github.com/babel/babel/tree/master/packages/babel-plugin-syntax-import-meta">babel-plugin-syntax-import-meta</a>. But trying to add this to a Webpack configuration - particularly as implemented by create-react-app - is, at best, a nightmare.</li>
</ul>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h4 id="demos">Demos:</h4>
<ul>
<li><a href="../../demo/canvas-007.html">Canvas-007</a> - Apply filters at the entity, group and cell level</li>
<li><a href="../../demo/component-004.html">Component-004</a> - Scrawl-canvas packets; save and load a range of different entitys</li>
</ul>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h4 id="imports">Imports</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">import</span> { constructors, cell, group, entity } <span class="hljs-keyword">from</span> <span class="hljs-string">'../core/library.js'</span>;
<span class="hljs-keyword">import</span> { mergeOver, removeItem } <span class="hljs-keyword">from</span> <span class="hljs-string">'../core/utilities.js'</span>;

<span class="hljs-keyword">import</span> baseMix <span class="hljs-keyword">from</span> <span class="hljs-string">'../mixin/base.js'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h4 id="filter-constructor">Filter constructor</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> Filter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items = {}</span>) </span>{

    <span class="hljs-keyword">this</span>.makeName(items.name);
    <span class="hljs-keyword">this</span>.register();
    <span class="hljs-keyword">this</span>.set(<span class="hljs-keyword">this</span>.defs);
    <span class="hljs-keyword">this</span>.set(items);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h4 id="filter-prototype">Filter prototype</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">let</span> P = Filter.prototype = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Object</span>.prototype);
P.type = <span class="hljs-string">'Filter'</span>;
P.lib = <span class="hljs-string">'filter'</span>;
P.isArtefact = <span class="hljs-literal">false</span>;
P.isAsset = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h4 id="mixins">Mixins</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>P = baseMix(P);</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h4 id="filter-attributes">Filter attributes</h4>
<ul>
<li>Attributes defined in the <a href="../mixin/base.html">base mixin</a>: <strong>name</strong>.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">let</span> defaultAttributes = {</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>All filters need to set out their <strong>method</strong>. For preset methods, a method string (eg â€˜grayscaleâ€™, â€˜sepiaâ€™) is sufficient. Bespoke methods require a function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    method: <span class="hljs-string">''</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>The following methods require no further attributes: </p>
<pre><code><span class="hljs-string">`grayscale`</span>, <span class="hljs-string">`sepia`</span>, <span class="hljs-string">`invert`</span>
<span class="hljs-string">`red`</span>, <span class="hljs-string">`green`</span>, <span class="hljs-string">`blue`</span>
<span class="hljs-string">`notred`</span>, <span class="hljs-string">`notgreen`</span>, <span class="hljs-string">`notblue`</span>
<span class="hljs-string">`cyan`</span>, <span class="hljs-string">`magenta`</span>, <span class="hljs-string">`yellow`</span></code></pre>
            </div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>The following methods require the <strong>level</strong> attribute:</p>
<pre><code><span class="hljs-string">`brightness`</span>, <span class="hljs-string">`saturation`</span>, <span class="hljs-string">`threshold`</span></code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>    level: <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>The <code>threshhold</code> filter will default to setting (desaturated) pixels below a given level (0 - 255) to black, and those above the level to white. These colours can be changed by using the <strong>low</strong> and <strong>high</strong> channel attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    lowRed: <span class="hljs-number">0</span>,
    <span class="hljs-attr">lowGreen</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">lowBlue</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">highRed</span>: <span class="hljs-number">255</span>,
    <span class="hljs-attr">highGreen</span>: <span class="hljs-number">255</span>,
    <span class="hljs-attr">highBlue</span>: <span class="hljs-number">255</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>The <code>channels</code> and <code>channelstep</code> methods make use of the <strong>red</strong>, <strong>green</strong> and <strong>blue</strong> attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    red: <span class="hljs-number">0</span>,
    <span class="hljs-attr">green</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">blue</span>: <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>The <code>tint</code> method uses nine attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    redInRed: <span class="hljs-number">0</span>,
    <span class="hljs-attr">redInGreen</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">redInBlue</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">greenInRed</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">greenInGreen</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">greenInBlue</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">blueInRed</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">blueInGreen</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">blueInBlue</span>: <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>The <code>pixelate</code> method requires tile dimensions and, optionally, offset coordinates which should not exceed the tile dimensions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    offsetX: <span class="hljs-number">0</span>,
    <span class="hljs-attr">offsetY</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">tileWidth</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">tileHeight</span>: <span class="hljs-number">1</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>The <code>blur</code> method uses the following attributes:</p>
<ul>
<li>the <strong>radius</strong> of the blur effect, in pixels</li>
<li>the <strong>passes</strong> attribute (1+) determines how many times the blur filter will iterate</li>
<li>the <strong>shrinkingRadius</strong> flag reduces the radius by approx 70% on each successive pass</li>
<li>when <strong>includeAlpha</strong> flag is true, filter will include the alpha channel - note this will make the edges of the entity translucent</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    radius: <span class="hljs-number">1</span>,
    <span class="hljs-attr">passes</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">shrinkingRadius</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">includeAlpha</span>: <span class="hljs-literal">false</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>The <code>matrix</code> method requires a weights attribute - an array of 9 numbers in the following format:</p>
<pre><code>weights: [
    topLeftWeight,
    topCenterWeight,
    topRightWeight,
    middleLeftWeight,
    homePixelWeight,
    middleRightWeight,
    bottomLeftWeight,
    bottomCenterWeight,
    bottomRightWeight,
]</code></pre><p>â€¦ where the top row is the row above the home pixel, etc</p>
<p>The method also makes use of the <strong>includeAlpha</strong> attribute.</p>

            </div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>The <code>matrix5</code> method is the same as the matrix method except that its weights array should contain 25 elements, to cover all the positions (from top-left corner) in a 5x5 grid</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    weights: <span class="hljs-literal">null</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>The <strong>ranges</strong> attribute - used by the <code>chroma</code> method - needs to be an array of arrays with the following format:</p>
<pre><code>[[minRed, minGreen, minBlue, maxRed, maxGreen, maxBlue], etc]</code></pre><p>â€¦ multiple ranges can be defined - for instance to key out the lightest and darkest hues:</p>
<pre><code>ranges: [[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">80</span>, <span class="hljs-number">80</span>, <span class="hljs-number">80</span>], [<span class="hljs-number">180</span>, <span class="hljs-number">180</span>, <span class="hljs-number">180</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>]]</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>    ranges: <span class="hljs-literal">null</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>The <code>user-defined</code> filter should be set as a String value of the functionâ€™s contents (the bits between the { curly braces }) on the <strong>userDefined</strong> attribute. The function can take no arguments, and can only use variables defined above (or the <strong>udVariableN</strong> attributes below). The function can also use <strong>self</strong> variables supplied by the web worker - see the worker/filter.js for more information</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    userDefined: <span class="hljs-string">''</span>,
    <span class="hljs-attr">udVariable0</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">udVariable1</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">udVariable2</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">udVariable3</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">udVariable4</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">udVariable5</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">udVariable6</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">udVariable7</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">udVariable8</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">udVariable9</span>: <span class="hljs-string">''</span>,
};
P.defs = mergeOver(P.defs, defaultAttributes);</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <h4 id="packet-management">Packet management</h4>
<p>No additional packet functionality required</p>

            </div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <h4 id="clone-management">Clone management</h4>
<p>No additional clone functionality required</p>

            </div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <h4 id="kill-management">Kill management</h4>
<p>Overwrites ./mixin/base.js</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>P.kill = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">let</span> myname = <span class="hljs-keyword">this</span>.name;</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Remove filter from all entity filters attribute</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">Object</span>.entries(entity).forEach(<span class="hljs-function">(<span class="hljs-params">[name, ent]</span>) =&gt;</span> {

        <span class="hljs-keyword">let</span> f = ent.filters;
        <span class="hljs-keyword">if</span> (f &amp;&amp; f.indexOf(myname) &gt;= <span class="hljs-number">0</span>) removeItem(f, myname);
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Remove filter from all group filters attribute</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">Object</span>.entries(group).forEach(<span class="hljs-function">(<span class="hljs-params">[name, grp]</span>) =&gt;</span> {

        <span class="hljs-keyword">let</span> f = grp.filters;
        <span class="hljs-keyword">if</span> (f &amp;&amp; f.indexOf(myname) &gt;= <span class="hljs-number">0</span>) removeItem(f, myname);
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Remove filter from all cell filters attribute</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">Object</span>.entries(cell).forEach(<span class="hljs-function">(<span class="hljs-params">[name, c]</span>) =&gt;</span> {

        <span class="hljs-keyword">let</span> f = c.filters;
        <span class="hljs-keyword">if</span> (f &amp;&amp; f.indexOf(myname) &gt;= <span class="hljs-number">0</span>) removeItem(f, myname);
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Remove filter from the Scrawl-canvas library</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.deregister();
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <h4 id="get-set-deltaset">Get, Set, deltaSet</h4>
<p>No additional functionality required</p>

            </div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <h4 id="prototype-functions">Prototype functions</h4>
<p>No additional prototype functions defined</p>

            </div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <h4 id="filter-webworker-pool">Filter webworker pool</h4>
<p>Because starting a web worker is an expensive operation, and a number of different filters may be required to render displays across a number of different &lt;canvas&gt; elements in a web page, Scrawl-canvas operates a pool of web workers to perform work as-and-when required.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> filterPool = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p><code>Exported function</code> <strong>requestFilterWorker</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> requestFilterWorker = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">if</span> (!filterPool.length) filterPool.push(buildFilterWorker());

    <span class="hljs-keyword">return</span> filterPool.shift();
};</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p><code>Exported function</code> <strong>releaseFilterWorker</strong> - to avoid memory leaks, <strong><em>all requested filter workers MUST be released back to the filter pool as soon as their work has completed</em></strong>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> releaseFilterWorker = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) </span>{

    filterPool.push(f);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p><strong>buildFilterWorker</strong> - create a new filter web worker</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> buildFilterWorker = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <h4 id="the-correct-code">The correct code</h4>
<p>This code has been commented out because of the Babel issue</p>
<ul>
<li>To use the worker file (as is right and proper!), uncomment the following 4 code lines and comment out all the <code>filterCode</code> and <code>filterUrl</code> code at the end of this file.</li>
</ul>

            </div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>let path = import.meta.url.slice(0, -(â€˜factory/filter.jsâ€™.length))</p>

            </div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>let filterUrl = (window.scrawlEnvironmentOffscreenCanvasSupported) ? 
    <code>${path}worker/filter.js</code> : 
    <code>${path}worker/filter.js</code>;</p>

            </div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Sept 2019 - chrome does not yet support module workers</p>
<pre><code><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Worker(filterUrl, {<span class="hljs-attr">type</span>: <span class="hljs-string">'module'</span>});</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Worker(filterUrl);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p><code>Exported function</code> <strong>actionFilterWorker</strong> - send a task to the filter web worker, and retrieve the resulting image. This function returns a Promise.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> actionFilterWorker = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">worker, items</span>) </span>{

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {

        worker.onmessage = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {

            <span class="hljs-keyword">if</span> (e &amp;&amp; e.data &amp;&amp; e.data.image) resolve(e.data.image);
            <span class="hljs-keyword">else</span> resolve(<span class="hljs-literal">false</span>);
        };

        worker.onerror = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {

            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'error'</span>, e.lineno, e.message);
            resolve(<span class="hljs-literal">false</span>);
        };

        worker.postMessage(items);
    });
};</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <h4 id="factory">Factory</h4>
<pre><code>scrawl.makeFilter({

    <span class="hljs-attr">name</span>: <span class="hljs-string">'my-grayscale-filter'</span>,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'grayscale'</span>,

}).clone({

    <span class="hljs-attr">name</span>: <span class="hljs-string">'my-sepia-filter'</span>,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'sepia'</span>,
});

scrawl.makeFilter({

    <span class="hljs-attr">name</span>: <span class="hljs-string">'my-chroma-filter'</span>,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'chroma'</span>,
    <span class="hljs-attr">ranges</span>: [[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">80</span>, <span class="hljs-number">80</span>, <span class="hljs-number">80</span>], [<span class="hljs-number">180</span>, <span class="hljs-number">180</span>, <span class="hljs-number">180</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>]],
});

scrawl.makeFilter({

    <span class="hljs-attr">name</span>: <span class="hljs-string">'venetian-blinds-filter'</span>,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'userDefined'</span>,

    <span class="hljs-attr">level</span>: <span class="hljs-number">9</span>,

    <span class="hljs-attr">userDefined</span>: <span class="hljs-string">`
        let i, iz, j, jz,
            level = filter.level || 6,
            halfLevel = level / 2,
            yw, transparent, pos;

        for (i = localY, iz = localY + localHeight; i &lt; iz; i++) {

            transparent = (i % level &gt; halfLevel) ? true : false;

            if (transparent) {

                yw = (i * iWidth) + 3;

                for (j = localX, jz = localX + localWidth; j &lt; jz; j ++) {

                    pos = yw + (j * 4);
                    data[pos] = 0;
                }
            }
        }`</span>,
});</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> makeFilter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items</span>) </span>{

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Filter(items);
};

constructors.Filter = Filter;</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <h4 id="temporary-fix-for-babels-current-inability-to-support">Temporary fix for Babelâ€™s current inability to support</h4>
<p>To temporarily fix the Babel issue, weâ€™ve copied all the code from the <a href="../mixin/filter.html">filter mixin</a> into this file, which we return from this function as a String.</p>
<ul>
<li>The String then gets used in the <code>filterUrl</code> const declaration (below) to create an object URL</li>
<li>We only want to perform this operation once because object urls are intense and ugly operations.</li>
</ul>
<p><strong>NOTE: any changes to filter code need to be replicated both in the mixin file, and in the String code here!</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> filterCode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">return</span> <span class="hljs-string">`
if (!Uint8Array.prototype.slice) {
    Object.defineProperty(Uint8Array.prototype, 'slice', {
        value: function (begin, end) {
            return new Uint8Array(Array.prototype.slice.call(this, begin, end));
        }
    });
}

let packet;
let image;
let iWidth;
let data;
let cache;
let tiles;
let localX;
let localY;
let localWidth;
let localHeight;
let filters;
let filter;
let action;

onmessage = function (e) {

    let i, iz;

    packet = e.data;
    image = packet.image;
    iWidth = image.width * 4;
    data = image.data;
    filters = packet.filters;

    getCache();
    getLocal();

    for (i = 0, iz = filters.length; i &lt; iz; i++) {

        filter = filters[i];

        if (filter.method === 'userDefined' &amp;&amp; filter.userDefined) actions.userDefined = new Function(filter.userDefined);

        action = actions[filter.method];

        if (action) action();
    }

    postMessage(packet);
};

onerror = function (e) {

    console.log('error' + e.message);
    postMessage(packet);
};

const getCache = function () {

    let i, iz;

    if (Array.isArray(cache)) cache.length = 0;
    else cache = [];

    for (i = 0, iz = data.length; i &lt; iz; i += 4) {

        if (data[i + 3]) cache.push(i);
    }
};

const getLocal = function () {

    let i, iz, w, h, minX, minY, maxX, maxY, x, y, val,
        floor = Math.floor;

    w = image.width;
    h = image.height;
    minX = w;
    minY = h;
    maxX = 0;
    maxY = 0;

    for (i = 0, iz = cache.length; i &lt; iz; i++) {

        val = cache[i] / 4;
        y = floor(val / w);
        x = val % w;
        minX = (x &lt; minX) ? x : minX;
        minY = (y &lt; minY) ? y : minY;
        maxX = (x &gt; maxX) ? x : maxX;
        maxY = (y &gt; maxY) ? y : maxY;
    }

    localX = minX;
    localY = minY;
    localWidth = maxX - minX;
    localHeight = maxY - minY;
};

const getTiles = function () {

    let i, iz, j, jz, x, xz, y, yz, startX, startY, pos, 
        hold = [],
        tileWidth = filter.tileWidth || 1,
        tileHeight = filter.tileHeight || 1,
        offsetX = filter.offsetX,
        offsetY = filter.offsetY,
        w = image.width,
        h = image.height;

    if (Array.isArray(tiles)) tiles.length = 0;
    else tiles = [];

    offsetX = (offsetX &gt;= tileWidth) ? tileWidth - 1 : offsetX;
    offsetY = (offsetY &gt;= tileHeight) ? tileHeight - 1 : offsetY;

    startX = (offsetX) ? offsetX - tileWidth : 0;
    startY = (offsetY) ? offsetY - tileHeight : 0;

    for (j = startY, jz = h + tileHeight; j &lt; jz; j += tileHeight) {

        for (i = startX, iz = w + tileWidth; i &lt; iz; i += tileWidth) {

            hold.length = 0;
            
            for (y = j, yz = j + tileHeight; y &lt; yz; y++) {

                if (y &gt;= 0 &amp;&amp; y &lt; h) {

                    for (x = i, xz = i + tileWidth; x &lt; xz; x++) {

                        if (x &gt;= 0 &amp;&amp; x &lt; w) {

                            pos = (y * iWidth) + (x * 4);

                            if (data[pos + 3]) hold.push(pos);
                        }
                    }
                }
            }
            if (hold.length) tiles.push([].concat(hold));
        }
    }
};

const average = function (c) {

    let a = 0,
        k, kz,
        l = c.length;

    if (l) {

        for (k = 0, kz = l; k &lt; kz; k++) {

            a +=c[k];
        }
        return a / l;
    }
    return 0;
};

const checkBounds = function (p) {

    let len = data.length;

    if (p &lt; 0) p += len;
    if (p &gt;= len) p -= len;
    return p;
};

const actions = {


    userDefined: function () {},

    grayscale: function () {

        let i, iz, pos, gray;

        for (i = 0, iz = cache.length; i &lt; iz; i++) {

            pos = cache[i];
            gray = (0.2126 * data[pos]) + (0.7152 * data[pos + 1]) + (0.0722 * data[pos + 2]);
            data[pos] = data[pos + 1] = data[pos + 2] = gray;
        }
    },

    sepia: function () {

        let i, iz, pos, r, g, b;

        for (i = 0, iz = cache.length; i &lt; iz; i++) {

            pos = cache[i];
            
            r = data[pos];
            g = data[pos + 1];
            b = data[pos + 2];
            
            data[pos] = (r * 0.393) + (g * 0.769) + (b * 0.189);
            data[pos + 1] = (r * 0.349) + (g * 0.686) + (b * 0.168);
            data[pos + 2] = (r * 0.272) + (g * 0.534) + (b * 0.131);
        }
    },

    invert: function () {

        let i, iz, pos;

        for (i = 0, iz = cache.length; i &lt; iz; i++) {

            pos = cache[i];
            data[pos] = 255 - data[pos];
            
            pos++;
            data[pos] = 255 - data[pos];
            
            pos++;
            data[pos] = 255 - data[pos];
        }
    },

    red: function () {

        let i, iz, pos;

        for (i = 0, iz = cache.length; i &lt; iz; i++) {

            pos = cache[i];
            data[pos + 1] = 0;
            data[pos + 2] = 0;
        }
    },

    green: function () {

        let i, iz, pos;

        for (i = 0, iz = cache.length; i &lt; iz; i++) {

            pos = cache[i];
            data[pos] = 0;
            data[pos + 2] = 0;
        }
    },

    blue: function () {

        let i, iz, pos;

        for (i = 0, iz = cache.length; i &lt; iz; i++) {

            pos = cache[i];
            data[pos] = 0;
            data[pos + 1] = 0;
        }
    },

    notred: function() {

        let i, iz, pos;

        for (i = 0, iz = cache.length; i &lt; iz; i++) {

            pos = cache[i];
            data[pos] = 0;
        }
    },

    notgreen: function () {

        let i, iz, pos;

        for (i = 0, iz = cache.length; i &lt; iz; i++) {

            pos = cache[i];
            data[pos + 1] = 0;
        }
    },

    notblue: function () {

        let i, iz, pos;

        for (i = 0, iz = cache.length; i &lt; iz; i++) {

            pos = cache[i];
            data[pos + 2] = 0;
        }
    },

    cyan: function () {

        let i, iz, pos, gray;

        for (i = 0, iz = cache.length; i &lt; iz; i++) {

            pos = cache[i];
            
            gray = (data[pos + 1] + data[pos + 2]) / 2;
            
            data[pos] = 0;
            data[pos + 1] = gray;
            data[pos + 2] = gray;
        }
    },

    magenta: function () {

        let i, iz, pos, gray;

        for (i = 0, iz = cache.length; i &lt; iz; i++) {

            pos = cache[i];

            gray = (data[pos] + data[pos + 2]) / 2;

            data[pos] = gray;
            data[pos + 1] = 0;
            data[pos + 2] = gray;
        }
    },

    yellow: function () {

        let i, iz, pos, gray;

        for (i = 0, iz = cache.length; i &lt; iz; i++) {

            pos = cache[i];
            
            gray = (data[pos] + data[pos + 1]) / 2;
            
            data[pos] = gray;
            data[pos + 1] = gray;
            data[pos + 2] = 0;
        }
    },

    brightness: function () {

        let i, iz, pos, 
            level = filter.level || 0;

        for (i = 0, iz = cache.length; i &lt; iz; i++) {

            pos = cache[i];
            data[pos] *= level;
            
            pos++;
            data[pos] *= level;
            
            pos++;
            data[pos] *= level;
        }
    },

    saturation: function () {

        let i, iz, pos, 
            level = filter.level || 0;

        for (i = 0, iz = cache.length; i &lt; iz; i++) {

            pos = cache[i];
            data[pos] = 127 + ((data[pos] - 127) * level);
            
            pos++;
            data[pos] = 127 + ((data[pos] - 127) * level);
            
            pos++;
            data[pos] = 127 + ((data[pos] - 127) * level);
        }
    },

    threshold: function () {

        let i, iz, pos, gray, test,
            level = filter.level || 0,
            lowRed = filter.lowRed,
            lowGreen = filter.lowGreen,
            lowBlue = filter.lowBlue,
            highRed = filter.highRed,
            highGreen = filter.highGreen,
            highBlue = filter.highBlue;

        for (i = 0, iz = cache.length; i &lt; iz; i++) {

            pos = cache[i];
            
            gray = (0.2126 * data[pos]) + (0.7152 * data[pos + 1]) + (0.0722 * data[pos + 2]);
            test = (gray &gt; level) ? true : false;
            
            if (test) {

                data[pos] = highRed;
                data[pos + 1] = highGreen;
                data[pos + 2] = highBlue;
            }
            else {

                data[pos] = lowRed;
                data[pos + 1] = lowGreen;
                data[pos + 2] = lowBlue;
            }
            
        }
    },

    channels: function () {

        let i, iz, pos,
            red = filter.red || 0,
            green = filter.green || 0,
            blue = filter.blue || 0;

        for (i = 0, iz = cache.length; i &lt; iz; i++) {

            pos = cache[i];
            
            data[pos] *= red;
            data[pos + 1] *= green;
            data[pos + 2] *= blue;
        }
    },

    channelstep: function () {

        let i, iz, pos,
            red = filter.red || 1,
            green = filter.green || 1,
            blue = filter.blue || 1,
            floor = Math.floor;

        for (i = 0, iz = cache.length; i &lt; iz; i++) {

            pos = cache[i];
            data[pos] = floor(data[pos] / red) * red;
            
            pos++;
            data[pos] = floor(data[pos] / green) * green;
            
            pos++;
            data[pos] = floor(data[pos] / blue) * blue;
        }
    },

    tint: function () {

        let i, iz, pos, r, g, b,
            redInRed = filter.redInRed || 0,
            redInGreen = filter.redInGreen || 0,
            redInBlue = filter.redInBlue || 0,
            greenInRed = filter.greenInRed || 0,
            greenInGreen = filter.greenInGreen || 0,
            greenInBlue = filter.greenInBlue || 0,
            blueInRed = filter.blueInRed || 0,
            blueInGreen = filter.blueInGreen || 0,
            blueInBlue = filter.blueInBlue || 0;

        for (i = 0, iz = cache.length; i &lt; iz; i++) {

            pos = cache[i];
            
            r = data[pos];
            g = data[pos + 1];
            b = data[pos + 2];
            
            data[pos] = (r * redInRed) + (g * greenInRed) + (b * blueInRed);
            data[pos + 1] = (r * redInGreen) + (g * greenInGreen) + (b * blueInGreen);
            data[pos + 2] = (r * redInBlue) + (g * greenInBlue) + (b * blueInBlue);
        }
    },

    chroma: function () {

        let pos, posA,
            ranges = filter.ranges,
            range, min, max, val,
            i, iz, j, jz, flag;

        for (j = 0, jz = cache.length; j &lt; jz; j++) {

            flag = false;

            for (i = 0, iz = ranges.length; i &lt; iz; i++) {

                posA = cache[j] + 3;
                range = ranges[i];
                min = range[2];
                pos = posA - 1;
                val = data[pos];

                if (val &gt;= min) {

                    max = range[5];

                    if (val &lt;= max) {

                        min = range[1];
                        pos--;
                        val = data[pos];

                        if (val &gt;= min) {

                            max = range[4];

                            if (val &lt;= max) {

                                min = range[0];
                                pos--;
                                val = data[pos];

                                if (val &gt;= min) {

                                    max = range[3];

                                    if (val &lt;= max) {
                                        flag = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (flag) data[posA] = 0;
        }
    },

    pixelate: function () {

        let i, iz, j, jz, pos, r, g, b, a, tile, len;

        getTiles();

        for (i = 0, iz = tiles.length; i &lt; iz; i++) {

            tile = tiles[i];
            r = g = b = a = 0;
            len = tile.length;

            if (len) {

                for (j = 0, jz = len; j &lt; jz; j++) {

                    pos = tile[j];

                    r += data[pos];
                    g += data[pos + 1];
                    b += data[pos + 2];
                    a += data[pos + 3];
                }

                r /= len;
                g /= len;
                b /= len;
                a /= len;

                for (j = 0, jz = len; j &lt; jz; j++) {

                    pos = tile[j];

                    data[pos] = r;
                    data[pos + 1] = g;
                    data[pos + 2] = b;
                    data[pos + 3] = a;
                }
            }
        }
    },

    blur: function () {

        if (data.slice) {

            let radius = filter.radius || 1,
                alpha = filter.includeAlpha || false,
                shrink = filter.shrinkingRadius || false,
                passes = filter.passes || 1,
                len = data.length,
                imageWidth = image.width,
                imageHeight = image.height,
                tempDataTo, tempDataFrom,
                i, iz, index;

            let processPass = function () {

                let j, jz;

                tempDataFrom = tempDataTo.slice(); 

                for (j = localX * 4, jz = (localX + localWidth) * 4; j &lt; jz; j++) {

                    if (alpha) processColumn(j);
                    else {

                        if (j % 4 !== 3) processColumn(j);
                    }
                }

                tempDataFrom = tempDataTo.slice(); 

                for (j = localY, jz = localY + localHeight; j &lt; jz; j++) {

                    if (alpha) processRowWithAlpha(j);
                    else processRowNoAlpha(j);
                }
            };

            let processColumn = function (col) {

                let pos, avg, val, cagePointer, y, yz, q, dataPointer,
                    vLead = radius * iWidth, 
                    cage = [],
                    cageLen;

                for (y = -radius, yz = radius; y &lt; yz; y++) {

                    pos = col + (y * iWidth);
                    pos = checkBounds(pos, len);
                    cage.push(tempDataFrom[pos]);
                }

                tempDataTo[col] = avg = average(cage);

                cageLen = cage.length;

                for (q = 0; q &lt; cageLen; q++) {

                    cage[q] /= cageLen;
                }

                cagePointer = 0;

                for (y = 1; y &lt; imageHeight; y++) {

                    avg -= cage[cagePointer];

                    dataPointer = col + (y * iWidth);
                    pos = dataPointer + vLead;
                    pos = checkBounds(pos, len);
                    val = tempDataFrom[pos] / cageLen;

                    avg += val;
                    cage[cagePointer] = val;
                    tempDataTo[dataPointer] = avg;

                    cagePointer++;

                    if (cagePointer === cageLen) cagePointer = 0;
                }
            };

            let processRowWithAlpha = function (row) {

                let pos, val, x, xz, q, avgQ, cageQ, rowPosX,
                    avg = [],
                    cage = [[], [], [], []],
                    rowPos = row * iWidth, 
                    hLead = radius * 4,
                    dataPointer, cagePointer, cageLen;

                q = 0;

                for (x = -radius * 4, xz = radius * 4; x &lt; xz; x++) {

                    pos = rowPos + x;
                    pos = checkBounds(pos, len);
                    
                    cage[q].push(tempDataFrom[pos]);
                    
                    q++;
                    if (q === 4) q = 0;
                }

                tempDataTo[rowPos] = avg[0] = average(cage[0]);
                tempDataTo[rowPos + 1] = avg[1] = average(cage[1]);
                tempDataTo[rowPos + 2] = avg[2] = average(cage[2]);
                tempDataTo[rowPos + 3] = avg[3] = average(cage[3]);

                cageLen = cage[0].length;

                for (q = 0; q &lt; 4; q++) {

                    for (x = 0; x &lt; cageLen; x++) {

                        cage[q][x] /= cageLen;
                    }
                }
                cagePointer = 0;

                for (x = 1; x &lt; imageHeight; x++) {

                    rowPosX = rowPos + (x * 4);

                    for (q = 0; q &lt; 4; q++) {

                        avgQ = avg[q];
                        cageQ = cage[q];
                        avgQ -= cageQ[cagePointer];

                        dataPointer = rowPosX + q;
                        pos = dataPointer + hLead;
                        pos = checkBounds(pos, len);
                        val = tempDataFrom[pos] / cageLen;

                        avgQ += val;
                        tempDataTo[dataPointer] = avgQ;
                        avg[q] = avgQ;
                        cageQ[cagePointer] = val;
                    }

                    cagePointer++;

                    if (cagePointer === cageLen) cagePointer = 0;
                }
            };

            let processRowNoAlpha = function (row) {

                let pos, val, x, xz, q, avgQ, cageQ, rowPosX,
                    avg = [],
                    hLead = radius * 4,
                    cage = [[], [], []],
                    rowPos = row * iWidth, 
                    dataPointer, cagePointer, cageLen;

                q = 0;

                for (x = -radius * 4, xz = radius * 4; x &lt; xz; x++) {

                    if (q &lt; 3) {

                        pos = rowPos + x;
                        pos = checkBounds(pos, len);
                        cage[q].push(tempDataFrom[pos]);
                        q++;
                    }
                    else q = 0;
                }

                tempDataTo[rowPos] = avg[0] = average(cage[0]);
                tempDataTo[rowPos + 1] = avg[1] = average(cage[1]);
                tempDataTo[rowPos + 2] = avg[2] = average(cage[2]);

                cageLen = cage[0].length;

                for (q = 0; q &lt; 3; q++) {

                    cageQ = cage[q];
                    
                    for (x = 0; x &lt; cageLen; x++) {

                        cageQ[x] /= cageLen;
                    }
                }
                cagePointer = 0;

                for (x = 1; x &lt; imageHeight; x++) {

                    rowPosX = rowPos + (x * 4);

                    for (q = 0; q &lt; 3; q++) {

                        avgQ = avg[q];
                        cageQ = cage[q];
                        avgQ -= cageQ[cagePointer];

                        dataPointer = rowPosX + q;
                        pos = dataPointer + hLead;
                        pos = checkBounds(pos, len);
                        val = tempDataFrom[pos] / cageLen;

                        avgQ += val;
                        tempDataTo[dataPointer] = avgQ;
                        avg[q] = avgQ;
                        cageQ[cagePointer] = val;
                    }

                    cagePointer++;
                    if (cagePointer === cageLen) cagePointer = 0;
                }
            };

            tempDataTo = data.slice();

            for (i = 0; i &lt; passes; i++) {

                processPass();
                
                if (shrink) {

                    radius = Math.ceil(radius * 0.3);
                    radius = (radius &lt; 1) ? 1 : radius;
                }
            }

            for (i = 0, iz = cache.length; i &lt; iz; i++) {

                index = cache[i];
                data[index] = tempDataTo[index];
                
                index++;
                data[index] = tempDataTo[index];
                
                index++;
                data[index] = tempDataTo[index];
                
                if (alpha) {

                    index++;
                    data[index] = tempDataTo[index];
                }
            }
        }
    },

    matrix: function () {

        let i, iz, j, jz, pos, weight, sumR, sumG, sumB, sumA, homePos,
            len = data.length,
            alpha = filter.includeAlpha || false,
            offset = [],
            weights = filter.weights || [0, 0, 0, 0, 1, 0, 0, 0, 0],
            tempCache = [],
            cursor = 0;

        offset[0] = -iWidth - 4;
        offset[1] = -iWidth;
        offset[2] = -iWidth + 4;
        offset[3] = -4;
        offset[4] = 0;
        offset[5] = 4;
        offset[6] = iWidth - 4;
        offset[7] = iWidth;
        offset[8] = iWidth + 4;

        for (i = 0, iz = cache.length; i &lt; iz; i++) {

            homePos = cache[i];
            sumR = sumG = sumB = sumA = 0;
            
            for (j = 0, jz = offset.length; j &lt; jz; j++) {

                pos = homePos + offset[j];
                
                if (pos &gt;= 0 &amp;&amp; pos &lt; len) {

                    weight = weights[j];
                    sumR += data[pos] * weight;
                    
                    pos++;
                    sumG += data[pos] * weight;
                    
                    pos++;
                    sumB += data[pos] * weight;
                    
                    if (alpha) {

                        pos++;
                        sumA += data[pos] * weight;
                    }
                }
            }

            tempCache[cursor] = sumR;
            cursor++;

            tempCache[cursor] = sumG;
            cursor++;

            tempCache[cursor] = sumB;
            cursor++;

            if (alpha) {

                tempCache[cursor] = sumA;
                cursor++;
            }
        }

        cursor = 0;

        for (i = 0, iz = cache.length; i &lt; iz; i++) {

            homePos = cache[i];
            data[homePos] = tempCache[cursor];
            cursor++;

            homePos++;
            data[homePos] = tempCache[cursor];
            cursor++;

            homePos++;
            data[homePos] = tempCache[cursor];
            cursor++;

            if (alpha) {

                homePos++;
                data[homePos] = tempCache[cursor];
                cursor++;
            }
        }
    },

    matrix5: function () {

        let i, iz, j, jz, pos, weight, sumR, sumG, sumB, sumA, homePos,
            len = data.length,
            alpha = filter.includeAlpha || false,
            offset = [],
            weights = filter.weights || [0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 1, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0],
            tempCache = [],
            iWidth2 = iWidth * 2,
            cursor = 0;

        offset[0] = -iWidth2 - 8;
        offset[1] = -iWidth2 - 4;
        offset[2] = -iWidth2;
        offset[3] = -iWidth2 + 4;
        offset[4] = -iWidth2 + 8;
        offset[5] = -iWidth - 8;
        offset[6] = -iWidth - 4;
        offset[7] = -iWidth;
        offset[8] = -iWidth + 4;
        offset[9] = -iWidth + 8;
        offset[10] = -8;
        offset[11] = -4;
        offset[12] = 0;
        offset[13] = 4;
        offset[14] = 8;
        offset[15] = iWidth - 8;
        offset[16] = iWidth - 4;
        offset[17] = iWidth;
        offset[18] = iWidth + 4;
        offset[19] = iWidth + 8;
        offset[20] = iWidth2 - 8;
        offset[21] = iWidth2 - 4;
        offset[22] = iWidth2;
        offset[23] = iWidth2 + 4;
        offset[24] = iWidth2 + 8;

        for (i = 0, iz = cache.length; i &lt; iz; i++) {

            homePos = cache[i];
            sumR = sumG = sumB = sumA = 0;
            
            for (j = 0, jz = offset.length; j &lt; jz; j++) {

                pos = homePos + offset[j];
                
                if (pos &gt;= 0 &amp;&amp; pos &lt; len) {

                    weight = weights[j];
                    sumR += data[pos] * weight;

                    pos++;
                    sumG += data[pos] * weight;

                    pos++;
                    sumB += data[pos] * weight;

                    if (alpha) {

                        pos++;
                        sumA += data[pos] * weight;
                    }
                }
            }

            tempCache[cursor] = sumR;
            cursor++;

            tempCache[cursor] = sumG;
            cursor++;

            tempCache[cursor] = sumB;
            cursor++;

            if (alpha) {

                tempCache[cursor] = sumA;
                cursor++;
            }
        }

        cursor = 0;

        for (i = 0, iz = cache.length; i &lt; iz; i++) {

            homePos = cache[i];
            data[homePos] = tempCache[cursor];
            cursor++;

            homePos++;
            data[homePos] = tempCache[cursor];
            cursor++;

            homePos++;
            data[homePos] = tempCache[cursor];
            cursor++;

            if (alpha) {
                
                homePos++;
                data[homePos] = tempCache[cursor];
                cursor++;
            }
        }
    },
};`</span>
};


<span class="hljs-keyword">const</span> filterUrl = URL.createObjectURL(

    <span class="hljs-keyword">new</span> Blob([ filterCode() ], { <span class="hljs-attr">type</span>: <span class="hljs-string">'text/javascript'</span> })
);</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <h4 id="exports">Exports</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">export</span> {
    makeFilter,
    requestFilterWorker,
    releaseFilterWorker,
    actionFilterWorker,
};</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
